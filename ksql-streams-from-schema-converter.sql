-- BLOB
-- parse blob stream
CREATE OR REPLACE STREAM FBNK_${procName}_MAPPED AS
SELECT
    AS_VALUE(DATA.ROWKEY) RECID,
    DATA.ROWKEY ROWKEY,
    DATA.LOOKUP_KEY LOOKUP_KEY,
    DATA.OP_TS OP_TS,
    DATA.CURRENT_TS REP_TS,
    DATA.`TABLE` TABLE_NAME,
    CAST(DATA.SCN AS BIGINT) COMMIT_SCN,
    DATA.OP_TYPE COMMIT_ACTION,
    PARSE_TIMESTAMP(
        TIMESTAMPTOSTRING(DATA.ROWTIME, 'yyyy-MM-dd HH:mm:ss.SSS'),
        'yyyy-MM-dd HH:mm:ss.SSS'
    ) CURRENT_TS,
    (
        CASE
            WHEN (DATA.OP_TYPE = 'D') THEN PARSE_T24_BLOB(
                DATA.BEFORE -> XMLRECORD,
				'${blobDelim}',
                'T24SS_${schemaName}-value',
                '#'
            )
            ELSE PARSE_T24_BLOB(
                DATA.AFTER -> XMLRECORD,
				'${blobDelim}',
                'T24SS_${schemaName}-value',
                '#'
            )
        END
    ) XMLRECORD
FROM FBNK_${procName} EMIT CHANGES;


-- DDL_MULTIVALUE
-- ddl multivalue
  CREATE TABLE DW_${procName}
   (  RECID VARCHAR2(200)  NOT NULL,
    V_M NUMBER NOT NULL,
    V_S NUMBER NOT NULL,
 
 
 
    COMMIT_SCN NUMBER,
    COMMIT_ACTION VARCHAR2(255),
    FLAG_STATUS VARCHAR2(255,)
    COMMIT_TS TIMESTAMP (6),  
    REPLICAT_TS TIMESTAMP (6),
    STREAM_TS TIMESTAMP (6),
    TIME_UPDATE TIMESTAMP (6),
  BANKING_DATE DATE NOT NULL) ;
-- Create/Recreate indexes
-- Create/Recreate primary, unique and foreign key constraints
alter table DW_${procName}
  add constraint DW_${procName}_PK primary key (RECID, BANKING_DATE,V_M, V_S);


-- DDL_SINGLE
-- ddl single
CREATE TABLE DW_${procName}
   (  RECID VARCHAR2(200)  NOT NULL,
 
 
 
    COMMIT_SCN NUMBER,
    COMMIT_ACTION VARCHAR2(255),
    COMMIT_TS TIMESTAMP (6),  
    REPLICAT_TS TIMESTAMP (6),
    STREAM_TS TIMESTAMP (6),
    TIME_UPDATE TIMESTAMP (6),
  BANKING_DATE DATE NOT NULL) ;
-- Create/Recreate indexes
-- Create/Recreate primary, unique and foreign key constraints
alter table DW_${procName}
  add constraint DW_${procName}_PK primary key (RECID, BANKING_DATE);


-- MULTIVALUE
-- parse multivalue stream
CREATE OR REPLACE STREAM FBNK_${procName}_MULTIVALUE AS SELECT
  DATA.ROWKEY ROWKEY,
  DATA.LOOKUP_KEY LOOKUP_KEY,
  DATA.RECID RECID,
  DATA.OP_TS OP_TS,
  DATA.CURRENT_TS REP_TS,
  TIMESTAMPTOSTRING(UNIX_TIMESTAMP(), 'yyyy-MM-dd HH:mm:ss.SSSSSS') CURRENT_TS,
  DATA.TABLE_NAME TABLE_NAME,
  DATA.COMMIT_SCN COMMIT_SCN,
  DATA.COMMIT_ACTION COMMIT_ACTION,
  ${listSelectedField}
  PARSE_T24_MULTIVAL(DATA.RECID, DATA.XMLRECORD, 'FBNK_${schemaName}_MULTIVALUE', ARRAY[${vm}], ARRAY[${vs}], '#') XMLRECORD --chọn delimiter nào ko xuất hiện trong value gốc VD:#
FROM FBNK_${procName}_MAPPED DATA
EMIT CHANGES;


-- RAW
-- raw/ogg stream
CREATE OR REPLACE STREAM FBNK_${procName} (
    ROWKEY STRING KEY,
    LOOKUP_KEY STRING,
    RECID STRING,
    `TABLE` STRING,
    SCN STRING,
    OP_TYPE STRING,
    OP_TS STRING,
    CURRENT_TS STRING,
    POS STRING,
    XID STRING,
    XMLRECORD STRING)
WITH (FORMAT='avro', KAFKA_TOPIC='FBNK_${procName}');


-- SINK
-- sink/final stream 
CREATE OR REPLACE 
STREAM DW_${procName} AS
SELECT
    DATA.ROWKEY ROWKEY,
  DATA.LOOKUP_KEY LOOKUP_KEY,
  DATA.RECID RECID,
  DATA.OP_TS OP_TS,
  DATA.REP_TS REP_TS,
  TIMESTAMPTOSTRING(UNIX_TIMESTAMP(), 'yyyy-MM-dd HH:mm:ss.SSSSSS') CURRENT_TS,
  PARSE_TIMESTAMP(DATA.OP_TS, 'yyyy-MM-dd HH:mm:ss.SSSSSS') COMMIT_TS,
  PARSE_TIMESTAMP(DATA.REP_TS, 'yyyy-MM-dd HH:mm:ss.SSSSSS') REPLICAT_TS,
  PARSE_TIMESTAMP(TIMESTAMPTOSTRING(UNIX_TIMESTAMP(), 'yyyy-MM-dd HH:mm:ss.SSSSSS'), 'yyyy-MM-dd HH:mm:ss.SSSSSS') STREAM_TS,
  DATA.TABLE_NAME TABLE_NAME,
  CAST(DATA.COMMIT_SCN AS BIGINT) COMMIT_SCN,
  DATA.COMMIT_ACTION COMMIT_ACTION,
    ${selectedFields}
	(CASE WHEN ((SCP.IS_COB_COMPLETED = true) AND (CAST(DATA.COMMIT_SCN AS BIGINT) > SCP.COMMIT_SCN)) THEN PARSE_DATE(SCP.TODAY, 'yyyyMMdd') ELSE PARSE_DATE(SCP.LAST_WORKING_DAY, 'yyyyMMdd') END) BANKING_DATE
FROM
    FBNK_${procName} DATA
    INNER JOIN FBNK_SEAB_COB_PROCESS_3_PART SCP ON (SCP.RECID = DATA.LOOKUP_KEY)
	PARTITION BY DATA.ROWKEY
	EMIT CHANGES;


-- SINK_MULTIVALUE
-- sink/final stream
CREATE OR REPLACE STREAM DW_${procName} WITH (PARTITIONS=3) AS SELECT
  DATA.ROWKEY ROWKEY,
  DATA.LOOKUP_KEY LOOKUP_KEY,
  DATA.RECID RECID,
  DATA.OP_TS OP_TS,
  DATA.REP_TS REP_TS,
  TIMESTAMPTOSTRING(UNIX_TIMESTAMP(), 'yyyy-MM-dd HH:mm:ss.SSSSSS') CURRENT_TS,
  PARSE_TIMESTAMP(DATA.OP_TS, 'yyyy-MM-dd HH:mm:ss.SSSSSS') COMMIT_TS,
  PARSE_TIMESTAMP(DATA.REP_TS, 'yyyy-MM-dd HH:mm:ss.SSSSSS') REPLICAT_TS,
  PARSE_TIMESTAMP(TIMESTAMPTOSTRING(UNIX_TIMESTAMP(), 'yyyy-MM-dd HH:mm:ss.SSSSSS'), 'yyyy-MM-dd HH:mm:ss.SSSSSS') STREAM_TS,
  DATA.TABLE_NAME TABLE_NAME,
  CAST(DATA.COMMIT_SCN AS BIGINT) COMMIT_SCN,
  DATA.COMMIT_ACTION COMMIT_ACTION,
      ${selectedFields}
  CAST(NVL(DATA.XMLRECORD['IDX'], '1') AS INTEGER) V_M,
  CAST(NVL(DATA.XMLRECORD['IDX_S'], '1') AS INTEGER) V_S,
  (CASE WHEN ((DATA.XMLRECORD['RECID'] = (DATA.RECID + '_TOMBSTONE')) OR (DATA.COMMIT_ACTION = 'D')) THEN 'D' ELSE 'LIVE' END) FLAG_STATUS,
  (CASE WHEN ((SCP.IS_COB_COMPLETED = true) AND (CAST(DATA.COMMIT_SCN AS BIGINT) > SCP.COMMIT_SCN)) THEN PARSE_DATE(SCP.TODAY, 'yyyyMMdd') ELSE PARSE_DATE(SCP.LAST_WORKING_DAY, 'yyyyMMdd') END) BANKING_DATE
FROM FBNK_${procName} DATA
INNER JOIN FBNK_SEAB_COB_PROCESS_3_PART SCP ON ((SCP.ROWKEY = DATA.LOOKUP_KEY)) --Team SB kiểm tra lại topic cần join --
PARTITION BY DATA.ROWKEY
EMIT CHANGES;


-- XML
-- parse xml stream 
CREATE OR REPLACE STREAM FBNK_${procName}_MAPPED  AS SELECT
  DATA.ROWKEY ROWKEY,
  DATA.LOOKUP_KEY LOOKUP_KEY,
  DATA.RECID RECID,  
  DATA.OP_TS OP_TS,  
  DATA.CURRENT_TS REP_TS,  
  TIMESTAMPTOSTRING(UNIX_TIMESTAMP(),'yyyy-MM-dd HH:mm:ss.SSSSSS') CURRENT_TS,
  DATA.`TABLE` TABLE_NAME,
  DATA.SCN COMMIT_SCN,  
  DATA.OP_TYPE COMMIT_ACTION, 
  PARSE_T24_RECORD(DATA.XMLRECORD, 'MAP_SS_TEST_${schemaName}-value', '#') XMLRECORD --chọn delimiter nào ko xuất hiện trong value gốc VD:#
FROM FBNK_${procName}  DATA
EMIT CHANGES;